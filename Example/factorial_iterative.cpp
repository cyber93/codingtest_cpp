//############################################################
// | cafe       | http://cafe.naver.com/dremdelover          |
// | Q&A        | https://open.kakao.com/o/gX0WnTCf          |
// | business   | ultrasuperrok@gmail.com                    |
//############################################################
#include <iostream>
#include <vector>

using namespace std;

// 동적 계획법을 사용하여 팩토리얼을 계산하는 함수
int factorial(int n) {
    // 크기 n+1의 벡터를 1로 초기화합니다.
    vector<int> dp(n + 1, 1); 

    // 팩토리얼 계산: dp[i]는 i! (i 팩토리얼)을 저장합니다.
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] * i;
    }

    // 결과로 n!을 반환합니다.
    return dp[n];
}

int main() {
    int n = 5; // 예시로 5의 팩토리얼을 계산
    cout << n << "! = " << factorial(n) << endl;

    n = 7; // 예시로 7의 팩토리얼을 계산
    cout << n << "! = " << factorial(n) << endl;

    return 0;
}

/*
동적 계획법(DP)와 팩토리얼 계산:

1. 동적 계획법(DP) 기본 원리:
   - 큰 문제를 작은 부분 문제로 분할하여 해결.
   - 동일한 부분 문제의 반복 계산을 피하기 위해 결과를 저장(memoization).
   - 시간 복잡도를 줄이고 효율성을 높이는 기법.

2. 중복 부분 문제(Overlapping Subproblems):
   - 동일한 작은 문제들이 여러 번 반복하여 계산되는 문제.
   - 예: 피보나치 수열에서 F(n) = F(n-1) + F(n-2) 계산 시, F(n-1)과 F(n-2)가 여러 번 중복 계산됨.
   - 동적 계획법은 이러한 중복 계산을 피하여 효율성을 높임.

3. 최적 부분 구조(Optimal Substructure):
   - 문제의 최적 해결 방법이 부분 문제의 최적 해결 방법으로 구성되는 성질.
   - 팩토리얼 계산에서 n! = n * (n-1)!의 형태로 나타남.
   - 예: 최단 경로 문제에서, 전체 경로의 최적해는 부분 경로의 최적해로 구성됨.

4. 팩토리얼 계산의 기본 원리:
   - 팩토리얼(n!)은 n * (n-1) * (n-2) * ... * 1의 곱셈으로 계산.
   - 즉, n! = n * (n-1)!

5. 팩토리얼 계산에 동적 계획법 적용:
   - dp[i]에 i!의 값을 저장하여 중복 계산을 피함.
   - 예: dp[3] = 3 * dp[2], dp[2] = 2 * dp[1] 등.

6. 팩토리얼 계산의 시간 복잡도:
   - 반복문을 사용하면 O(n) 시간 복잡도로 계산 가능.
   - 동적 계획법을 사용해도 시간 복잡도는 여전히 O(n).

7. 동적 계획법의 효율성 향상이 어려운 이유:
   - 팩토리얼 문제는 중복 부분 문제가 존재하지 않음.
   - 각 단계에서 이전 단계의 결과를 단순히 곱하는 형태.
   - 추가적인 메모리 공간 사용(dp 배열)이 필요하지만 시간 복잡도 개선 효과는 없음.

결론:
   - 팩토리얼 계산 문제는 최적 부분 구조를 가지지만, 중복 부분 문제가 없기 때문에 
     동적 계획법의 이점(시간 복잡도 감소)을 크게 활용할 수 없음.
   - 따라서, DP를 적용해도 효율성 개선은 미미함.
*/
