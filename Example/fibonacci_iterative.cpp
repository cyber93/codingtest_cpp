//############################################################
// | cafe       | http://cafe.naver.com/dremdelover          |
// | Q&A        | https://open.kakao.com/o/gX0WnTCf          |
// | business   | ultrasuperrok@gmail.com                    |
//############################################################

#include <iostream>
#include <vector>

using namespace std;

// 동적 계획법을 사용하여 피보나치 수열을 계산하는 함수
int fibonacci(int n) {
    // 크기 n+1의 벡터를 0으로 초기화합니다.
    vector<int> dp(n + 1, 0); 

    // 초기 조건 설정
    dp[0] = 0;
    if (n > 0) {
        dp[1] = 1;
    }

    // 피보나치 수열 계산: dp[i]는 i번째 피보나치 수를 저장합니다.
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    // 결과로 n번째 피보나치 수를 반환합니다.
    return dp[n];
}

int main() {
    int n = 5; // 예시로 5번째 피보나치 수를 계산
    cout << "Fibonacci(" << n << ") = " << fibonacci(n) << endl;

    n = 10; // 예시로 10번째 피보나치 수를 계산
    cout << "Fibonacci(" << n << ") = " << fibonacci(n) << endl;

    return 0;
}

/*
동적 계획법(DP)와 피보나치 수열 계산:

1. 동적 계획법(DP) 기본 원리:
   - 큰 문제를 작은 부분 문제로 분할하여 해결.
   - 동일한 부분 문제의 반복 계산을 피하기 위해 결과를 저장(memoization).
   - 시간 복잡도를 줄이고 효율성을 높이는 기법.

2. 중복 부분 문제(Overlapping Subproblems):
   - 동일한 작은 문제들이 여러 번 반복하여 계산되는 문제.
   - 피보나치 수열의 경우, F(n) = F(n-1) + F(n-2)에서 F(n-1)과 F(n-2)가 여러 번 계산됨.
   - 예: F(5)를 계산할 때, F(4)와 F(3)를 계산하고, F(4)를 계산할 때 다시 F(3)와 F(2)를 계산함.
   - 동적 계획법은 이러한 중복 계산을 피하여 효율성을 높임.

3. 최적 부분 구조(Optimal Substructure):
   - 문제의 최적 해결 방법이 부분 문제의 최적 해결 방법으로 구성되는 성질.
   - 피보나치 수열 계산에서 F(n)은 F(n-1)과 F(n-2)의 결과로 구성됨.
   - 즉, F(n)의 최적해는 F(n-1)과 F(n-2)의 최적해로 구성됨.

4. 피보나치 수열 계산의 기본 원리:
   - 피보나치 수열은 다음과 같이 정의됨: 
     F(0) = 0, F(1) = 1
     F(n) = F(n-1) + F(n-2) (n >= 2)

5. 피보나치 수열 계산에 동적 계획법 적용:
   - dp[i]에 i번째 피보나치 수를 저장하여 중복 계산을 피함.
   - 예: dp[5] = dp[4] + dp[3], dp[4] = dp[3] + dp[2] 등.

6. 피보나치 수열 계산의 시간 복잡도:
   - 반복문을 사용하면 O(n) 시간 복잡도로 계산 가능.
   - 동적 계획법을 사용하면 중복 계산을 피하여 O(n) 시간 복잡도로 효율적 계산.

결론:
   - 피보나치 수열 문제는 DP의 이점(시간 복잡도 감소)을 크게 활용할 수 있음.
   - 중복 부분 문제와 최적 부분 구조를 가지므로 DP를 적용하면 효율성 개선이 큼.
*/
